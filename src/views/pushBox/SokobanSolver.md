# 推箱子游戏求解器架构设计

## 整体架构

推箱子求解器是一个基于搜索算法的游戏自动求解系统，主要由以下几个核心部分组成：

1. **状态表示**：使用`State`类表示游戏的每个状态
2. **状态转移**：通过`getNextStates`方法生成所有可能的下一步状态
3. **搜索算法**：使用广度优先搜索(BFS)寻找从初始状态到目标状态的路径
4. **死锁检测**：通过`computeDeadlocks`方法预先计算不可能完成游戏的位置
5. **Web Worker实现**：使用Web Worker在后台线程执行求解算法，避免阻塞主线程

## 核心数据结构

### 位置表示

```typescript
type Position = [number, number] // [行, 列]
```

### 状态类 (State)

状态类表示游戏中的一个状态，包含以下信息：

- `playerPos`: 玩家位置
- `boxes`: 箱子位置集合
- `parent`: 父状态，用于回溯路径
- `direction`: 从父状态到达当前状态的移动方向
- `steps`: 从初始状态到当前状态的步数

状态类还实现了哈希计算和状态比较方法，用于状态去重：

- `getHash()`: 生成状态的唯一哈希值
- `equals()`: 比较两个状态是否相同

### 求解器类 (SokobanSolver)

求解器类实现了推箱子游戏的核心求解逻辑，包含以下主要属性：

- `gameMap`: 游戏地图
- `height`, `width`: 地图尺寸
- `playerPos`: 玩家初始位置
- `boxes`: 箱子初始位置集合
- `targets`: 目标位置集合
- `walls`: 墙壁位置集合
- `deadlockPositions`: 死锁位置集合

## 核心算法

### 地图解析

`parseMap()`方法解析游戏地图，初始化各种位置集合：

- 0: 空地
- 1: 墙
- 3: 目标点
- 4: 箱子
- 5: 箱子在目标点上
- 6: 玩家
- 7: 玩家在目标点上

### 死锁检测

`computeDeadlocks()`方法计算死锁位置，主要检测角落和边缘位置。死锁位置是指箱子推到这些位置后，无法再推到目标点的位置。

主要检测方法：

1. 检查每个非墙非目标的位置
2. 计算周围墙壁数量
3. 如果周围有至少两面墙，检查是否形成角落
4. 如果两个相邻方向都是墙，则形成角落，是死锁位置

### 状态转移

`getNextStates()`方法生成当前状态的所有可能的下一步状态：

1. 尝试四个方向的移动
2. 检查新位置是否有效
3. 如果新位置有箱子，尝试推动箱子
4. 如果箱子可以被推动且新位置不是死锁位置，添加到结果中
5. 如果新位置没有箱子，直接移动

### 广度优先搜索

`solveBfs()`方法使用广度优先搜索算法寻找从初始状态到目标状态的路径：

1. 创建初始状态并加入队列
2. 循环处理队列中的状态
3. 如果当前状态是目标状态，返回路径
4. 获取所有可能的下一步状态
5. 如果状态未访问过，加入队列
6. 如果队列为空，说明无解

## Web Worker实现

为了避免求解过程阻塞主线程，系统使用Web Worker在后台线程执行求解算法：

1. 主线程发送包含游戏地图的消息给Worker
2. Worker接收消息并创建求解器
3. Worker执行求解算法并将结果发送回主线程

## 性能优化

1. **状态哈希缓存**：使用`_hash`缓存状态哈希值，避免重复计算
2. **死锁检测**：预先计算死锁位置，避免搜索无效路径
3. **状态去重**：使用哈希集合避免重复访问相同状态
4. **Web Worker**：使用后台线程执行求解算法，避免阻塞主线程

## 扩展可能性

1. **启发式搜索**：实现A\*算法，使用启发函数加速搜索
2. **更复杂的死锁检测**：实现更多类型的死锁检测，如隧道死锁、冻结箱子检测等
3. **多线程并行搜索**：使用多个Worker并行搜索不同路径
4. **解决方案优化**：实现路径优化，找到最短路径
